---
layout: post
title:  "The Rise and Fall of Ideologies in Software Development"
date:   2014-07-28 14:09:10
---
I find in science that there are few things are more fashionable than software development. Software developers are not known for their orthodoxy. Unnatural sleeping hours, caveman-esque subsistence, hippy fashion, beer and pizza stereotypes aside, most have a tendency to be infected with with rabid evangelistic fever towards a particular cult of software development one year, only to find themselves stunned by alternative methodologies and processes the next.

One is often left scratching oneâ€™s head, as to why such pandemics pop up so repeatedly within the highly intellectual and wired software engineering herd, but it certainly makes for a fascinating discussion topic and point.

Perhaps this manifestation is a reflection of the difficulty inherent in software engineering. In terms of physical overhead and monetary capital, software engineering is comparatively light. Almost anyone with internet access and a computer can start downloading interpreters and playing around with compilers and APIs. One is not encumbered by regulation, patents, logistical requirements, and physical constraints that plague most other business. Unlike the heavy upfront model of that these other businesses follow, software engineering costs are spread more gradually over time.

Yet the time required to master all the details required to build even a simple product that people will readily use is real and exhausting. Because of the substantial time constraints required to master even a small fragment of technology, developers have a tendency to be singularly invested in a small set of technologies, only moving on to the next when potential has been thoroughly exhausted. This large premium but almost certain return-of-investment discourages developers to explore fringe technologies. Very few engineers have the leisure or motivation to drill in and thoroughly flush out the current technology they employ much less other competing technologies. This results in a narrow mindset, where rationale and arguments are based on higher order principles and heuristics such as object-orientedness, test driven development, type safety, et cetera rather than on practical experience and usability.

Companies and organizations backing a particular technology are incentivized to communicate to their core audience, developers, on these higher order principles, in order to sell that particular technology. They are ideas that most developers would readily understand regardless of language fragmentation, whether they are a Java developer, a .NET developer, a Ruby-on-Rails developer, a mobile developer, a web developer, or something else. For example, Sun Microsystems, the company behind Java, would expound on the benefits object-oriented programming and type-safety, because Java is the prototypical, classically object-oriented language. The Ruby community, on the other hand, would expound on the benefits of test-driven development and behavior-driven development, because Ruby enables TDD and BDD better than any other programming language. Selling to developers on these higher order ideas, is almost always more cost-effective than selling to them low level details and case-by-case experience.

Given enough hot air, these software development ideologies have a tendency to inflate and float away, only to be rejected as insufficient or distasteful a few years later, when a new contrasting ideology provides a starker alternative. Such is the case too, for many other higher order ideas not grounded by reality.
